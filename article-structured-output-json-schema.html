<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="UdKSEhF53U7UM_M7tJ1jzITrxm5OrgypZyEDoSuUhtQ" />
    <meta name="description" content="Replace fragile regex parsing with native LLM structured output. Learn JSON Schema validation, type safety, and production-ready response handling for PMCR-O agents.">
    <meta name="author" content="Shawn Delaine Bellazan">
    <meta name="keywords" content="Structured Output, JSON Schema, LLM Output, Type Safety, Ollama, PMCR-O, AI Agents">
    <meta name="theme-color" content="#d4a574">
    <link rel="icon" href="assets/favicon/favicon.svg" type="image/svg+xml">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://shawndelainebellazan.com/article-structured-output-json-schema.html">
    <meta property="og:title" content="Structured Output with JSON Schema | Shawn Bellazan">
    <meta property="og:description" content="Replace fragile regex parsing with native LLM structured output. Learn JSON Schema validation and type safety.">
    <meta property="og:image" content="https://shawndelainebellazan.com/assets/images/og-image.svg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Structured Output with JSON Schema">
    <meta name="twitter:description" content="Replace fragile regex parsing with native LLM structured output.">
    <meta name="twitter:image" content="https://shawndelainebellazan.com/assets/images/og-image.svg">
    <title>Structured Output with JSON Schema | Shawn Bellazan</title>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Structured Output with JSON Schema",
      "description": "Replace fragile regex parsing with native LLM structured output. Learn JSON Schema validation, type safety, and production-ready response handling for PMCR-O agents.",
      "datePublished": "2026-01-01",
      "dateModified": "2026-01-01",
      "author": {
        "@type": "Person",
        "@id": "https://shawndelainebellazan.com/#person",
        "name": "Shawn Delaine Bellazan",
        "jobTitle": "Resilient Architect",
        "url": "https://shawndelainebellazan.com"
      },
      "publisher": {
        "@type": "Organization",
        "name": "Tooensure LLC",
        "@id": "https://tooensure.com/#organization",
        "url": "https://tooensure.com"
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://shawndelainebellazan.com/article-structured-output-json-schema"
      },
      "keywords": ["Structured Output", "JSON Schema", "LLM Output", "Type Safety"]
    }
    </script>
    <link rel="canonical" href="https://shawndelainebellazan.com/article-structured-output-json-schema.html">
    <!-- Prism.js for syntax highlighting (Enterprise-grade code display) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="style.css">
    <style>
        .article-container { max-width: 800px; margin: 0 auto; padding: 3rem 2rem; }
        .article-meta { color: var(--text-tertiary); font-size: 0.9rem; margin-bottom: 2rem; }
        .article-content h2 { font-size: 2rem; color: var(--gold); margin: 3rem 0 1.5rem; font-weight: var(--font-weight-bold); }
        .article-content h3 { font-size: 1.5rem; color: var(--gold-light); margin: 2rem 0 1rem; }
        .code-block-wrapper { position: relative; margin: 2rem 0; background: var(--gray); border: 1px solid var(--light-gray); border-radius: 8px; overflow: hidden; }
        .code-block-header { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; background: rgba(0, 0, 0, 0.3); border-bottom: 1px solid var(--light-gray); }
        .code-language { color: var(--gold); font-size: 0.85rem; font-weight: 600; text-transform: uppercase; }
        .copy-button { padding: 0.4rem 1rem; font-size: 0.8rem; background: transparent; border: 1px solid var(--gold); color: var(--gold); cursor: pointer; border-radius: 4px; transition: all var(--transition-fast); }
        .copy-button:hover { background: var(--gold); color: var(--darker); }
        pre[class*="language-"] { margin: 0; padding: 1.5rem; overflow-x: auto; }
        .callout { background: linear-gradient(135deg, rgba(212, 165, 116, 0.1) 0%, rgba(212, 165, 116, 0.05) 100%); border-left: 4px solid var(--gold); padding: 1.5rem; margin: 2rem 0; border-radius: 8px; }
        .back-link { display: inline-block; color: var(--gold); text-decoration: none; margin-bottom: 2rem; font-weight: 600; }
        .back-link:hover { color: var(--gold-light); }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <nav role="navigation" aria-label="Main navigation">
        <div class="container">
            <a href="index.html" class="logo" aria-label="Shawn Bellazan - Home">SHAWN BELLAZAN</a>
            <button class="mobile-menu-toggle" aria-label="Toggle mobile menu" aria-expanded="false">
                <span></span><span></span><span></span>
            </button>
            <ul class="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="index.html#work">Work</a></li>
                <li><a href="pmcro-codex.html">PMCR-O</a></li>
                <li><a href="pmcro-prompt-library.html">Agents</a></li>
                <li><a href="articles.html">Articles</a></li>
                <li><a href="index.html#contact">Contact</a></li>
            </ul>
        </div>
    </nav>
    <main id="main-content" style="margin-top: 80px;">
        <section class="hero">
            <div class="hero-content" style="text-align: center; max-width: 800px; margin: 0 auto;">
                <h1 style="color: var(--gold); font-size: clamp(2.5rem, 5vw, 4rem); margin-bottom: 1rem;">Structured Output with JSON Schema</h1>
                <p class="hero-subtitle" style="font-size: 1.2rem; color: var(--text-tertiary); font-style: italic;">From fragile regex parsing to native type-safe LLM responses.</p>
            </div>
        </section>
        <div class="article-container">
            <a href="articles.html" class="back-link">← Back to Articles</a>
            <div class="article-meta">By Shawn Delaine Bellazan • January 1, 2026 • 10 min read</div>
            <div class="article-content">
                <p>Traditional prompt engineering extracts JSON from text using regex or bracket counting—fragile, error-prone, and maintenance-heavy. <strong>Structured output</strong> tells the LLM to output only JSON, validated against a schema.</p>

                <p>This guide shows you how to implement structured output in PMCR-O agents using Microsoft.Extensions.AI and <a href="article-setting-up-ollama-gpu.html" style="color: var(--gold);">Ollama</a>. It assumes you have <a href="article-bip-prompt-engineering-guide.html" style="color: var(--gold);">BIP</a> fundamentals.</p>

                <h2>The Problem: Fragile Parsing</h2>
                <p>The <a href="article-building-self-referential-agents-part1.html" style="color: var(--gold);">old way used custom parsing logic</a>:</p>
                
                <div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">C#</span>
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-csharp">// ❌ DON'T DO THIS
var response = await _chatClient.CompleteChatAsync(history);
var jsonBlocks = ExtractJsonBlocksUsingBracketCounter(response.Content);
foreach (var block in jsonBlocks)
{
    try 
    { 
        var parsed = JsonDocument.Parse(block);
        // Hope this is the right one...
    }
    catch 
    { 
        // Try next block...
    }
}</code></pre>
                </div>

                <p><strong>Problems:</strong></p>
                <ul>
                    <li>~85% success rate (fails on edge cases)</li>
                    <li>50-200ms parsing overhead</li>
                    <li>200+ lines of fragile parsing code</li>
                    <li>Breaks when LLM output format changes</li>
                </ul>

                <h2>The Solution: Native Structured Output</h2>
                <p>Modern LLMs (including Ollama) support structured output via JSON schema. Tell the model to output only JSON:</p>
                
                <div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">C#</span>
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-csharp">var chatOptions = new ChatOptions
{
    ResponseFormat = ChatResponseFormat.Json,  // ✅ Magic: output only JSON
    AdditionalProperties = new Dictionary&lt;string, object?&gt;
    {
        ["schema"] = JsonSerializer.Serialize(new
        {
            type = "object",
            properties = new
            {
                plan = new { type = "string" },
                steps = new
                {
                    type = "array",
                    items = new
                    {
                        type = "object",
                        properties = new
                        {
                            action = new { type = "string" },
                            rationale = new { type = "string" }
                        }
                    }
                }
            },
            required = new[] { "plan", "steps" }
        })
    }
};

var response = await _chatClient.CompleteChatAsync(history, chatOptions);
var plan = JsonSerializer.Deserialize&lt;PlanResponse&gt;(response.Content);  // ✅ Direct deserialization</code></pre>
                </div>

                <h2>Benefits</h2>
                <ul>
                    <li><strong>~99% success rate:</strong> Schema-enforced validation</li>
                    <li><strong>&lt;1ms deserialization:</strong> No parsing overhead</li>
                    <li><strong>0 lines of parsing code:</strong> Native framework support</li>
                    <li><strong>Type safety:</strong> Compile-time validation</li>
                </ul>

                <h2>Complete Example: Planner Agent</h2>
                <p>Here's a complete implementation:</p>
                
                <div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">C#</span>
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-csharp">public class PlanResponse
{
    public string Plan { get; set; } = "";
    public List&lt;PlanStep&gt; Steps { get; set; } = new();
    public string EstimatedComplexity { get; set; } = "";
}

public class PlanStep
{
    public string Action { get; set; } = "";
    public string Rationale { get; set; } = "";
}

public override async Task&lt;AgentResponse&gt; ExecuteTask(
    AgentRequest request,
    ServerCallContext context)
{
    var chatOptions = new ChatOptions
    {
        Temperature = 0.7,
        ResponseFormat = ChatResponseFormat.Json,
        AdditionalProperties = new Dictionary&lt;string, object?&gt;
        {
            ["schema"] = JsonSerializer.Serialize(new
            {
                type = "object",
                properties = new
                {
                    plan = new { type = "string", description = "The implementation plan" },
                    steps = new
                    {
                        type = "array",
                        items = new
                        {
                            type = "object",
                            properties = new
                            {
                                action = new { type = "string" },
                                rationale = new { type = "string" }
                            },
                            required = new[] { "action", "rationale" }
                        }
                    },
                    estimated_complexity = new 
                    { 
                        type = "string", 
                        @enum = new[] { "low", "medium", "high" } 
                    }
                },
                required = new[] { "plan", "steps" }
            })
        }
    };

    var response = await _chatClient.CompleteChatAsync(history, chatOptions);
    
    // Direct deserialization - no parsing needed!
    var plan = JsonSerializer.Deserialize&lt;PlanResponse&gt;(response.Content);
    
    return new AgentResponse
    {
        Content = JsonSerializer.Serialize(plan),
        Success = plan != null
    };
}</code></pre>
                </div>

                <h2>Schema Design Best Practices</h2>
                
                <h3>1. Use Descriptive Property Names</h3>
                <div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">JSON</span>
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-json">{
  "properties": {
    "plan": {
      "type": "string",
      "description": "The implementation plan in one sentence"
    }
  }
}</code></pre>
                </div>

                <h3>2. Mark Required Fields</h3>
                <div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">JSON</span>
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-json">{
  "required": ["plan", "steps"]
}</code></pre>
                </div>

                <h3>3. Use Enums for Constrained Values</h3>
                <div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">JSON</span>
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-json">{
  "estimated_complexity": {
    "type": "string",
    "enum": ["low", "medium", "high"]
  }
}</code></pre>
                </div>

                <h2>Error Handling</h2>
                <p>Even with structured output, validation is recommended:</p>
                
                <div class="code-block-wrapper">
                    <div class="code-block-header">
                        <span class="code-language">C#</span>
                        <button class="copy-button" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-csharp">try
{
    var response = await _chatClient.CompleteChatAsync(history, chatOptions);
    var plan = JsonSerializer.Deserialize&lt;PlanResponse&gt;(response.Content);
    
    if (plan == null || string.IsNullOrEmpty(plan.Plan))
    {
        _logger.LogWarning("Planner returned invalid response");
        return new AgentResponse { Success = false, Content = "Invalid plan structure" };
    }
    
    return new AgentResponse { Success = true, Content = JsonSerializer.Serialize(plan) };
}
catch (JsonException ex)
{
    _logger.LogError(ex, "Failed to deserialize planner response");
    return new AgentResponse { Success = false, Content = "JSON parsing error" };
}</code></pre>
                </div>

                <h2>Next Steps</h2>
                <ul>
                    <li>Read <a href="article-creating-first-pmcro-agent.html" style="color: var(--gold);">Creating Your First PMCR-O Agent</a> for complete implementation</li>
                    <li>Explore the <a href="articles.html" style="color: var(--gold);">complete article library</a></li>
                </ul>

                <div class="callout" style="margin: 3rem 0; text-align: center;">
                    <h3 style="color: var(--gold); margin-bottom: 1rem;">Build Your Own Strange Loop</h3>
                    <p>The PMCR-O framework is open. Star the repository. Fork it. Seed your own intent.</p>
                    <p style="margin-top: 1rem;">
                        <a href="https://github.com/tooensure" target="_blank" rel="noopener noreferrer" style="color: var(--gold); text-decoration: underline; font-weight: 600;">View on GitHub →</a>
                    </p>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2026 Shawn Delaine Bellazan. All rights reserved.</p>
            <p class="footer-tagline">Strength in vulnerability. Power in expression. Resilience in architecture.</p>
        </div>
    </footer>
    <script src="site.js"></script>
    <script src="main.js"></script>
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script>
        /**
         * Copy code block to clipboard
         * Enterprise-grade: Handles clipboard API with fallback for file:// protocol
         */
        function copyCode(button) {
            const codeBlock = button.closest('.code-block-wrapper').querySelector('code');
            if (!codeBlock) return;
            
            const text = codeBlock.textContent;
            
            // Use modern Clipboard API with fallback
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    button.textContent = 'Copied!';
                    setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                }).catch(() => {
                    // Fallback for file:// protocol or clipboard errors
                    fallbackCopyTextToClipboard(text, button);
                });
            } else {
                fallbackCopyTextToClipboard(text, button);
            }
        }
        
        function fallbackCopyTextToClipboard(text, button) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                button.textContent = 'Copied!';
                setTimeout(() => { button.textContent = 'Copy'; }, 2000);
            } catch (err) {
                console.error('Fallback copy failed:', err);
            }
            document.body.removeChild(textArea);
        }
    </script>
</body>
</html>

